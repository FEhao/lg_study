## 简答题

#### 1. 描述引用计数的工作原理和优缺点

**答:**

引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的。同时引用计数还可以指使用引用计数技术回收未使用资源的垃圾回收算法。当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。

```js
var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集

var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

优点：1. 发现垃圾时立即回收； 2.最大限度减少程序暂停

缺点：1. 无法处理循环引用，引用计数算法考虑到循环引用对象之间互相都有至少一次引用，所以它们不会被回收； 2. 时间开销大



#### 2. 描述标记整理算法的工作流程

**答:**

1. 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记

2. 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

      

#### 3.描述V8中新生代存储区垃圾回收的流程

**答:**

1. 新生代内存分为两个等大空间，处于使用中的空间为From，处于闲置中的空间为To
2. 在垃圾回收运行时，会检查 From中的对象，当某个对象需要被回收时，将其留在 From 空间，剩下的对象移动到To空间
3. From与To交换空间，释放原来的From空间



#### 4. 描述增量标记算法在何时使用，及工作原理

**答:**

垃圾回收需要暂停程序，执行GC，这就导致在GC执行期间，程序得不到执行，因此出现了`增量式垃圾回收`，它并不会等GC执行完才将控制权交回程序，而是分步执行，逐步完成垃圾回收在程序运行中穿插进行。极大地降低了GC的最大暂停时间。

在V8的分代垃圾回收中，一次小垃圾回收只搜集新生代，由于新生代空间较小，且存活对象也较少，所以全停顿影响不大。但对于老生代，空间配置大，存活对象多，垃圾的标记，清理，整理等动作会占用很大的时间。

为了降低全堆垃圾回收带来的停顿时间，V8在标记时采用增量标记（incremental marking），即将标记拆分为许多小步进，每一个步进完成时，就让js逻辑执行一小会。垃圾回收和逻辑执行交替进行，直到标记阶段完成。



## 代码题1

> 详见code/app1.js

#### 1. 使用函数组合 `fp.flowRight()` 重新实现下面这个函数

**答:**

````js
let isLastInStockFP = fp.flowRight(fp.prop("in_stock"), fp.last);
````



#### 2. 使用 `fp.flowRight()` 、`fp.prop()` 和 `fp.first()` 获取第一个 car 的 name

**答:**

````js
let getFistName = fp.flowRight(fp.prop("name"), fp.first);
````



#### 3. 使用帮助函数 `_average` 重构 `averageDollarValue` ，使用函数组合的方式实现

**答:**

````js
let averageDollarValue = fp.flowRight(_average, fp.map(fp.prop('dollar_value')));
````



#### 4. 使用 `flowRight` 写一个 `sanitizeNames` 函数，返回一个下划线连接的小写字符串，把数组中的 `name` 转为这种形式：例如：`sanitizeNames(['Hello World']) => ['hello_world']`

**答:**

````js
let sanitizeNames = fp.flowRight(fp.map(fp.flowRight(fp.toLower, _underscore)))
````



## 代码题2

> 详见code/app2.js

#### 1. 使用 `fp.add(x, y)` 和 `fp.map(f, x)` 创建一个能让 functor 里的值增加的函数 `ex1`

**答:**

````js
let ex1 = num => maybe.map(fp.map(fp.add(num)))._value
````



#### 2. 实现一个函数 `ex2` ，能够使用 `fp.first` 获取列表的第一个元素

**答:**

````js
let ex2 = () => xs.map(fp.first)._value
````



#### 3. 实现一个函数 `ex3` ，使用 `safeProp` 和 `fp.first` 找到 user 的名字的首字母

**答:**

````js
let ex3 = user => safeProp('name')(user).map(fp.first)._value
````



#### 4. 使用 `Maybe` 重写 `ex4` ，不要有 `if` 语句

**答:**

````js
let ex42 = function (n) {
  return Maybe.of(n).map(parseInt)._value || undefined
}
````

