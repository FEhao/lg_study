1. JS 中的内存管理：申请内存空间；使用内存空间；释放内存空间

2. JS 中的垃圾

   1. JS 中内存管理是自动的
   2. 对象不在被引用时是垃圾
   3. 对象不能从根上访问到时是垃圾

3. JS 中的可达对象

   1. 可以访问到的对象就是可达对象（引用、作用域链）
   2. 可达的标准就是从根出发是否能被找到
   3. JS 中的根可以理解为是全局变量对象

4. GC 定义与作用

   1. 垃圾回收机制，垃圾回收器完成具体的工作
   2. 可以找到内存中的垃圾，并释放和回收空间
   3. GC 算法是工作时查找和回收所遵循的规则

5. GC 算法

   1. 引用计数（早期浏览器）
      1. 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

      2. 设置引用数，判断当前引用数是否为 0

      3. 引用计数器

      4. 引用关系改变时修改引用数字（+ -）

      5. 引用数字为 0 时立即回收

      6. 优点

         1. 发现垃圾时立即回收
         2. 最大限度减少程序暂停

      7. 缺点

         1. 无法回收循环引用对象

         2. 时间开销大

         3. ```js
            function fn() {
              const obj1 = {};
              const obj2 = {};
              obj1.name = obj2;
              obj2.name = obj1;
              return "";
            }
            //	按理说全局上找不到obj1,obj2，所以应该回收，但存在互相引用，引用计数不为0，未被回收
            fn();
            ```

   2. 标记清除（主流浏览器）

      1. 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
      2. 核心思想：分标记和清除两个阶段完成
      3. 遍历所有对象找标记活动对象（如果有引用层次，会进行递归；对于上例函数体内互相引用，因为无法从根上访问到，所以不会被标记）
      4. 遍历所有对象清除没有标记对象
      5. 回收相应空间
      6. 优点：解决循环引用问题
      7. 缺点：空间碎片化
         1. ![avatar](../Images/标记清除缺点.png)

   3. 标记整理

      1. 可以看做是标记清除的增强
      2. 标记阶段操作和标记清除一致
      3. 清除阶段会先执行整理，移动对象位置
      4. ![avatar](../Images/标记整理流程.jpeg)

   4. 分代回收

6. V8

   1. 主流的 js 执行引擎
7. 采用即时编译
   
   1. V8 内存设限
8. 回收策略
   
   1. 采用分代回收的思想
      1. 内存分为新生代，老生代
   2. ![avatar](../Images/v8垃圾回收策略.png)
   
      1. V8 中常用 GC 算法
         1. 分代回收
      2. 空间复制
         1. 标记清除
         2. 标记整理
         3. 标记增量
   3. 内存分配： From, To, 老生代存储区
      1. 小空间用于存储新生代对象（32M | 16M）
      2. 新生代指的是存活时间较短的对象，比如局部
9. 新生代对象回收实现
      1. 回收过程采用**复制算法 + 标记整理**
      2. 新生代内存区分为两个等大小的空间
      3. 使用空间为From，空闲空间为To
      4. 活动对象存储于From空间
      5. 标记整理后将活动对象拷贝至To
      6. From与To交换空间完成释放
      7. [具体流程参考此帖][https://juejin.im/post/5ad3f1156fb9a028b86e78be]
      8. 回收细节说明
         1. 拷贝过程中可能出现晋升
         2. 晋升就是将新生代对象移动至老生代
         3. 一轮GC还存活的新生代需要晋升（当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理）
      4. To空间的使用率超过25%（当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配）
   9. 老生代对象说明
      1. 存放在右侧老生代区域
      2. 64位操作系统1.4G，32位700M
      3. 老生代对象就是指存活时间较长的对象，在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题：1. 由于存活对象较多，复制存活对象的效率会很低。2. 采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。
   10. 老生代对象回收实现
      1. 主要采用**标记清除、标记整理、增量标记**算法
      2. 首先使用标记清除完成垃圾空间的回收
      3. 采用标记整理进行空间优化
      4. 采用增量标记进行效率优化
      5. 细节对比
         1. 新生代区域垃圾回收使用空间换时间（from和to）
         2. 老生代区域垃圾回收不适合复制算法
      6. 标记增量如何优化垃圾回收
         1. ![avatar](../Images/标记增量.png)
   
   
   
   
