1. JS中的内存管理：申请内存空间；使用内存空间；释放内存空间

2. JS中的垃圾
   1. JS中内存管理是自动的
   2. 对象不在被引用时是垃圾
   3. 对象不能从根上访问到时是垃圾
   
3. JS中的可达对象
   1. 可以访问到的对象就是可达对象（引用、作用域链）
   2. 可达的标准就是从根出发是否能被找到
   3. JS中的根可以理解为是全局变量对象
   
4. GC定义与作用

   1. 垃圾回收机制，垃圾回收器完成具体的工作
   2. 可以找到内存中的垃圾，并释放和回收空间
   3. GC算法是工作时查找和回收所遵循的规则

5. GC算法

   1. 引用计数

      1. 设置引用数，判断当前引用数是否为0

      2. 引用计数器

      3. 引用关系改变时修改引用数字（+ -）

      4. 引用数字为0时立即回收

      5. 优点

         1. 发现垃圾时立即回收
         2. 最大限度减少程序暂停

      6. 缺点

         1. 无法回收循环引用对象

         2. 时间开销大

         3. ````js
            function fn() {
              const obj1 = {}
              const obj2 = {}
              obj1.name = obj2
              obj2.name = obj1
              return ''
            }
            //	按理说全局上找不到obj1,obj2，所以应该回收，但存在互相引用，引用计数不为0，未被回收
            fn()
            ````

   2. 标记清除

      1. 核心思想：分标记和清除两个阶段完成
      2. 遍历所有对象找标记活动对象（如果有引用层次，会进行递归；对于上例函数体内互相引用，因为无法从根上访问到，所以不会被标记）
      3. 遍历所有对象清除没有标记对象
      4. 回收相应空间
      5. 优点：解决循环引用问题
      6. 缺点：空间碎片化
         1. ![avatar](../Images/标记清除缺点.png)

   3. 标记整理

      1. 可以看做是标记清除的增强
      2. 标记阶段操作和标记清除一致
      3. 清除阶段会先执行整理，移动对象位置
      4. ![avatar](../Images/标记整理流程.jpeg)

   4.  分代回收

